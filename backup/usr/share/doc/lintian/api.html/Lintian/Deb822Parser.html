<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Lintian::Deb822Parser</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Debian_control_parsers'>Debian control parsers</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#CONSTANTS'>CONSTANTS</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Lintian::Deb822Parser - Lintian&#39;s generic Deb822 parser functions</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> use Lintian::Deb822Parser qw(read_dpkg_control_utf8);
 
 my (@paragraphs);
 eval { @paragraphs = read_dpkg_control_utf8(&#39;some/debian/ctrl/file&#39;); };
 if ($@) {
    # syntax error etc.
    die &#34;ctrl/file: $@&#34;;
 }
 
 foreach my $para (@paragraphs) {
    my $value = $para-&#62;{&#39;some-field&#39;};
    if (defined $value) {
        # ...
    }
 }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module contains a number of utility subs that are nice to have, but on their own did not warrant their own module.</p>

<p>Most subs are imported only on request.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Debian_control_parsers"
>Debian control parsers</a></h2>

<p>At first glance, this module appears to contain several debian control parsers. In practise, there is only one real parser (<a href="#visit_dpkg_paragraph" class="podlinkpod"
>&#34;visit_dpkg_paragraph&#34;</a>) - the rest are convenience functions around it.</p>

<p>If you have very large files (e.g. Packages_amd64), you almost certainly want <a href="#visit_dpkg_paragraph" class="podlinkpod"
>&#34;visit_dpkg_paragraph&#34;</a>. Otherwise, one of the convenience functions are probably what you are looking for.</p>

<dl>
<dt><a name="Use_&#34;get_deb_info&#34;_in_Lintian::Util_when"
>Use <a href="../Lintian/Util.html#get_deb_info" class="podlinkpod"
>&#34;get_deb_info&#34; in Lintian::Util</a> when</a></dt>

<dd>
<p>You have a <i>.deb</i> (or <i>.udeb</i>) file and you want the control file from it.</p>

<dt><a name="Use_&#34;get_dsc_info&#34;_in_Lintian::Util_when"
>Use <a href="../Lintian/Util.html#get_dsc_info" class="podlinkpod"
>&#34;get_dsc_info&#34; in Lintian::Util</a> when</a></dt>

<dd>
<p>You have a <i>.dsc</i> (or <i>.changes</i>) file. Alternative, it is also useful if you have a control file and only care about the first paragraph.</p>

<dt><a name="Use_&#34;read_dpkg_control_utf8&#34;_or_&#34;read_dpkg_control&#34;_when"
>Use <a href="#read_dpkg_control_utf8" class="podlinkpod"
>&#34;read_dpkg_control_utf8&#34;</a> or <a href="#read_dpkg_control" class="podlinkpod"
>&#34;read_dpkg_control&#34;</a> when</a></dt>

<dd>
<p>You have a debian control file (such <i>debian/control</i>) and you want a number of paragraphs from it.</p>

<dt><a name="Use_&#34;parse_dpkg_control&#34;_when"
>Use <a href="#parse_dpkg_control" class="podlinkpod"
>&#34;parse_dpkg_control&#34;</a> when</a></dt>

<dd>
<p>When you would have used <a href="#read_dpkg_control_utf8" class="podlinkpod"
>&#34;read_dpkg_control_utf8&#34;</a>, except you have an open filehandle rather than a file name.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="CONSTANTS"
>CONSTANTS</a></h1>

<p>The following constants can be passed to the Debian control file parser functions to alter their parsing flag.</p>

<dl>
<dt><a name="DCTRL_DEBCONF_TEMPLATE"
>DCTRL_DEBCONF_TEMPLATE</a></dt>

<dd>
<p>The file should be parsed as debconf template. These have slightly syntax rules for whitespace in some cases.</p>

<dt><a name="DCTRL_NO_COMMENTS"
>DCTRL_NO_COMMENTS</a></dt>

<dd>
<p>The file do not allow comments. With this flag, any comment in the file is considered a syntax error.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<dl>
<dt><a name="parse_dpkg_control(HANDLE[,_FLAGS[,_LINES]])"
>parse_dpkg_control(HANDLE[, FLAGS[, LINES]])</a></dt>

<dd>
<p>Reads a debian control file from HANDLE and returns a list of paragraphs in it. A paragraph is represented via a hashref, which maps (lower cased) field names to their values.</p>

<p>FLAGS (if given) is a bitmask of the <i>DCTRL_*</i> constants. Please refer to <a href="#CONSTANTS" class="podlinkpod"
>&#34;CONSTANTS&#34;</a> for the list of constants and their meaning. The default value for FLAGS is 0.</p>

<p>If LINES is given, it should be a reference to an empty list. On return, LINES will be populated with a hashref for each paragraph (in the same order as the returned list). Each hashref will also have a special key &#34;<i>START-OF-PARAGRAPH</i>&#34; that gives the line number of the first field in that paragraph. These hashrefs will map the field name of the given paragraph to the line number where the field name appeared.</p>

<p>This is a convenience sub around <a href="#visit_dpkg_paragraph" class="podlinkpod"
>&#34;visit_dpkg_paragraph&#34;</a> and can therefore produce the same errors as it. Please see <a href="#visit_dpkg_paragraph" class="podlinkpod"
>&#34;visit_dpkg_paragraph&#34;</a> for the finer semantics of how the control file is parsed.</p>

<p>NB: parse_dpkg_control does <i>not</i> close the handle for the caller.</p>

<dt><a name="visit_dpkg_paragraph_(CODE,_HANDLE[,_FLAGS])"
>visit_dpkg_paragraph (CODE, HANDLE[, FLAGS])</a></dt>

<dd>
<p>Reads a debian control file from HANDLE and passes each paragraph to CODE. A paragraph is represented via a hashref, which maps (lower cased) field names to their values.</p>

<p>FLAGS (if given) is a bitmask of the <i>DCTRL_*</i> constants. Please refer to <a href="#CONSTANTS" class="podlinkpod"
>&#34;CONSTANTS&#34;</a> for the list of constants and their meaning. The default value for FLAGS is 0.</p>

<p>If the file is empty (i.e. it contains no paragraphs), the method will contain an <i>empty</i> list. The deb822 contents may be inside a <i>signed</i> PGP message with a signature.</p>

<p>visit_dpkg_paragraph will require the PGP headers to be correct (if present) and require that the entire file is covered by the signature. However, it will <i>not</i> validate the signature (in fact, the contents of the PGP SIGNATURE part can be empty). The signature should be validated separately.</p>

<p>visit_dpkg_paragraph will pass paragraphs to CODE as they are completed. If CODE can process the paragraphs as they are seen, very large control files can be processed without keeping all the paragraphs in memory.</p>

<p>As a consequence of how the file is parsed, CODE may be passed a number of (valid) paragraphs before parsing is stopped due to a syntax error.</p>

<p>NB: visit_dpkg_paragraph does <i>not</i> close the handle for the caller.</p>

<p>CODE is expected to be a callable reference (e.g. a sub) and will be invoked as the following:</p>

<dl>
<dt><a name="CODE-&#62;(PARA,_LINE_NUMBERS)"
>CODE-&#62;(PARA, LINE_NUMBERS)</a></dt>

<dd>
<p>The first argument, PARA, is a hashref to the most recent paragraph parsed. The second argument, LINE_NUMBERS, is a hashref mapping each of the field names to the line number where the field name appeared. LINE_NUMBERS will also have a special key &#34;<i>START-OF-PARAGRAPH</i>&#34; that gives the line number of the first field in that paragraph.</p>

<p>The return value of CODE is ignored.</p>

<p>If the CODE invokes die (or similar) the error is propagated to the caller.</p>
</dd>
</dl>

<p><i>On syntax errors</i>, visit_dpkg_paragraph will call die with the following string:</p>

<pre>  &#34;syntax error at line %d: %s\n&#34;</pre>

<p>Where %d is the line number of the issue and %s is one of:</p>

<dl>
<dt><a name="Duplicate_field_%s"
>Duplicate field %s</a></dt>

<dd>
<p>The field appeared twice in the paragraph.</p>

<dt><a name="Continuation_line_outside_a_paragraph_(maybe_line_%d_should_be_&#34;_.&#34;)"
>Continuation line outside a paragraph (maybe line %d should be &#34; .&#34;)</a></dt>

<dd>
<p>A continuation line appears outside a paragraph - usually caused by an unintended empty line before it.</p>

<dt><a name="Whitespace_line_not_allowed_(possibly_missing_a_&#34;.&#34;)"
>Whitespace line not allowed (possibly missing a &#34;.&#34;)</a></dt>

<dd>
<p>An empty continuation line was found. This usually means that a period is missing to denote an &#34;empty line&#34; in (e.g.) the long description of a package.</p>

<dt><a name="Cannot_parse_line_&#34;%s&#34;"
>Cannot parse line &#34;%s&#34;</a></dt>

<dd>
<p>Generic error containing the text of the line that confused the parser. Note that all non-printables in %s will be replaced by underscores.</p>

<dt><a name="Comments_are_not_allowed"
>Comments are not allowed</a></dt>

<dd>
<p>A comment line appeared and FLAGS contained DCTRL_NO_COMMENTS.</p>

<dt><a name="PGP_signature_seen_before_start_of_signed_message"
>PGP signature seen before start of signed message</a></dt>

<dd>
<p>A &#34;BEGIN PGP SIGNATURE&#34; header is seen and a &#34;BEGIN PGP MESSAGE&#34; has not been seen yet.</p>

<dt><a name="Two_PGP_signatures_(first_one_at_line_%d)"
>Two PGP signatures (first one at line %d)</a></dt>

<dd>
<p>Two &#34;BEGIN PGP SIGNATURE&#34; headers are seen in the same file.</p>

<dt><a name="Unexpected_%s_header"
>Unexpected %s header</a></dt>

<dd>
<p>A valid PGP header appears (e.g. &#34;BEGIN PUBLIC KEY BLOCK&#34;).</p>

<dt><a name="Malformed_PGP_header"
>Malformed PGP header</a></dt>

<dd>
<p>An invalid or malformed PGP header appears.</p>

<dt><a name="Expected_at_most_one_signed_message_(previous_at_line_%d)"
>Expected at most one signed message (previous at line %d)</a></dt>

<dd>
<p>Two &#34;BEGIN PGP MESSAGE&#34; headers appears in the same message.</p>

<dt><a name="End_of_file_but_expected_an_&#34;END_PGP_SIGNATURE&#34;_header"
>End of file but expected an &#34;END PGP SIGNATURE&#34; header</a></dt>

<dd>
<p>The file ended after a &#34;BEGIN PGP SIGNATURE&#34; header without being followed by an &#34;END PGP SIGNATURE&#34;.</p>

<dt><a name="PGP_MESSAGE_header_must_be_first_content_if_present"
>PGP MESSAGE header must be first content if present</a></dt>

<dd>
<p>The file had content before PGP MESSAGE.</p>

<dt><a name="Data_after_the_PGP_SIGNATURE"
>Data after the PGP SIGNATURE</a></dt>

<dd>
<p>The file had data after the PGP SIGNATURE block ended.</p>

<dt><a name="End_of_file_before_&#34;BEGIN_PGP_SIGNATURE&#34;"
>End of file before &#34;BEGIN PGP SIGNATURE&#34;</a></dt>

<dd>
<p>The file had a &#34;BEGIN PGP MESSAGE&#34; header, but no signature was present.</p>
</dd>
</dl>

<dt><a name="read_dpkg_control_utf8(FILE[,_FLAGS[,_LINES]])"
>read_dpkg_control_utf8(FILE[, FLAGS[, LINES]])</a></dt>

<dd>
<dt><a name="read_dpkg_control(FILE[,_FLAGS[,_LINES]])"
>read_dpkg_control(FILE[, FLAGS[, LINES]])</a></dt>

<dd>
<p>This is a convenience function to ease using <a href="#parse_dpkg_control" class="podlinkpod"
>&#34;parse_dpkg_control&#34;</a> with paths to files (rather than open handles). The first argument must be the path to a FILE, which should be read as a debian control file. If the file is empty, an empty list is returned.</p>

<p>Otherwise, this behaves like:</p>

<pre> use autodie;
 
 open(my $fd, &#39;&#60;:encoding(UTF-8)&#39;, FILE); # or &#39;&#60;&#39;
 my @p = parse_dpkg_control($fd, FLAGS, LINES);
 close($fd);
 return @p;</pre>

<p>This goes without saying that may fail with any of the messages that <a href="#parse_dpkg_control(HANDLE%5B%2C_FLAGS%5B%2C_LINES%5D%5D)" class="podlinkpod"
>&#34;parse_dpkg_control(HANDLE[, FLAGS[, LINES]])&#34;</a> do. It can also emit autodie exceptions if open or close fails.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>lintian(1)</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
