<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html><head><title>Lintian::Util</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<link rel="stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="blkmagw" type="text/css" href="../_blkmagw.css" media="all" >
<link rel="alternate stylesheet" title="blkcynw" type="text/css" href="../_blkcynw.css" media="all" >
<link rel="alternate stylesheet" title="whtprpk" type="text/css" href="../_whtprpk.css" media="all" >
<link rel="alternate stylesheet" title="whtnavk" type="text/css" href="../_whtnavk.css" media="all" >
<link rel="alternate stylesheet" title="grygrnk" type="text/css" href="../_grygrnk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="blkgrng" type="text/css" href="../_blkgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >
<link rel="alternate stylesheet" title="blkbluw" type="text/css" href="../_blkbluw.css" media="all" >
<link rel="alternate stylesheet" title="whtpurk" type="text/css" href="../_whtpurk.css" media="all" >
<link rel="alternate stylesheet" title="whtgrng" type="text/css" href="../_whtgrng.css" media="all" >
<link rel="alternate stylesheet" title="grygrnw" type="text/css" href="../_grygrnw.css" media="all" >

<script type="text/javascript" src="../_podly.js"></script>

</head>
<body class='pod'>

<!-- start doc -->
<p class="backlinktop"><b><a name="___top" href="../index.html" accesskey="1" title="All Documents">&lt;&lt;</a></b></p>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <li class='indexItem indexItem1'><a href='#VARIABLES'>VARIABLES</a>
  <li class='indexItem indexItem1'><a href='#FUNCTIONS'>FUNCTIONS</a>
  <li class='indexItem indexItem1'><a href='#SEE_ALSO'>SEE ALSO</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Lintian::Util - Lintian utility functions</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre> use Lintian::Util qw(normalize_pkg_path);

 my $path = normalize_pkg_path(&#39;usr/bin/&#39;, &#39;../lib/git-core/git-pull&#39;);
 if (defined $path) {
    # ...
 }</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>This module contains a number of utility subs that are nice to have, but on their own did not warrant their own module.</p>

<p>Most subs are imported only on request.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VARIABLES"
>VARIABLES</a></h1>

<dl>
<dt><a name="$PKGNAME_REGEX"
>$PKGNAME_REGEX</a></dt>

<dd>
<p>Regular expression that matches valid package names. The expression is not anchored and does not enforce any &#34;boundary&#34; characters.</p>

<dt><a name="$PKGREPACK_REGEX"
>$PKGREPACK_REGEX</a></dt>

<dd>
<p>Regular expression that matches &#34;repacked&#34; package names. The expression is not anchored and does not enforce any &#34;boundary&#34; characters.</p>

<dt><a name="$PKGVERSION_REGEX"
>$PKGVERSION_REGEX</a></dt>

<dd>
<p>Regular expression that matches valid package versions. The expression is not anchored and does not enforce any &#34;boundary&#34; characters.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="FUNCTIONS"
>FUNCTIONS</a></h1>

<dl>
<dt><a name="get_deb_info(DEBFILE)"
>get_deb_info(DEBFILE)</a></dt>

<dd>
<p>Extracts the control file from DEBFILE and returns it as a hashref.</p>

<p>Basically, this is a fancy convenience for setting up an ar + tar pipe and passing said pipe to <a href="#parse_dpkg_control(HANDLE%5B%2C_FLAGS%5B%2C_LINES%5D%5D)" class="podlinkpod"
>&#34;parse_dpkg_control(HANDLE[, FLAGS[, LINES]])&#34;</a>.</p>

<p>DEBFILE must be an ar file containing a &#34;control.tar.gz&#34; member, which in turn should contain a &#34;control&#34; file. If the &#34;control&#34; file is empty this will return an empty list.</p>

<p>Note: the control file is only expected to have a single paragraph and thus only the first is returned (in the unlikely case that there are more than one).</p>

<p>This function may fail with any of the messages that <a href="#parse_dpkg_control" class="podlinkpod"
>&#34;parse_dpkg_control&#34;</a> do. It can also emit:</p>

<pre> &#34;cannot fork to unpack %s: %s\n&#34;</pre>

<dt><a name="get_dsc_control_(DSCFILE)"
>get_dsc_control (DSCFILE)</a></dt>

<dd>
<p>Convenience function for reading dsc files. It will read the DSCFILE using <a href="#read_dpkg_control(FILE%5B%2C_FLAGS%5B%2C_LINES%5D%5D)" class="podlinkpod"
>&#34;read_dpkg_control(FILE[, FLAGS[, LINES]])&#34;</a> and then return the first paragraph. If the file has no paragraphs, <code>undef</code> is returned instead.</p>

<p>Note: the control file is only expected to have a single paragraph and thus only the first is returned (in the unlikely case that there are more than one).</p>

<p>This function may fail with any of the messages that <a href="#read_dpkg_control(FILE%5B%2C_FLAGS%5B%2C_LINES%5D%5D)" class="podlinkpod"
>&#34;read_dpkg_control(FILE[, FLAGS[, LINES]])&#34;</a> do.</p>

<dt><a name="drain_pipe(FD)"
>drain_pipe(FD)</a></dt>

<dd>
<p>Reads and discards any remaining contents from FD, which is assumed to be a pipe. This is mostly done to avoid having the &#34;write&#34;-end die with a SIGPIPE due to a &#34;broken pipe&#34; (which can happen if you just close the pipe).</p>

<p>May cause an exception if there are issues reading from the pipe.</p>

<p>Caveat: This will block until the pipe is closed from the &#34;write&#34;-end, so only use it with pipes where the &#34;write&#34;-end will eventually close their end by themselves (or something else will make them close it).</p>

<dt><a name="get_file_digest(ALGO,_FILE)"
>get_file_digest(ALGO, FILE)</a></dt>

<dd>
<p>Creates an ALGO digest object that is seeded with the contents of FILE. If you just want the hex digest, please use <a href="#get_file_checksum(ALGO%2C_FILE)" class="podlinkpod"
>&#34;get_file_checksum(ALGO, FILE)&#34;</a> instead.</p>

<p>ALGO can be &#39;md5&#39; or shaX, where X is any number supported by <a href="../Digest/SHA.html" class="podlinkpod"
>Digest::SHA</a> (e.g. &#39;sha256&#39;).</p>

<p>This sub is a convenience wrapper around Digest::{MD5,SHA}.</p>

<dt><a name="get_file_checksum(ALGO,_FILE)"
>get_file_checksum(ALGO, FILE)</a></dt>

<dd>
<p>Returns a hexadecimal string of the message digest checksum generated by the algorithm ALGO on FILE.</p>

<p>ALGO can be &#39;md5&#39; or shaX, where X is any number supported by <a href="../Digest/SHA.html" class="podlinkpod"
>Digest::SHA</a> (e.g. &#39;sha256&#39;).</p>

<p>This sub is a convenience wrapper around Digest::{MD5,SHA}.</p>

<dt><a name="is_string_utf8_encoded(STRING)"
>is_string_utf8_encoded(STRING)</a></dt>

<dd>
<p>Returns a truth value if STRING can be decoded as valid UTF-8.</p>

<dt><a name="file_is_encoded_in_non_utf8_(...)"
>file_is_encoded_in_non_utf8 (...)</a></dt>

<dd>
<p>Undocumented</p>

<dt><a name="do_fork()"
>do_fork()</a></dt>

<dd>
<p>Overrides fork to reset signal handlers etc. in the child.</p>

<dt><a name="clean_env_([CLOC])"
>clean_env ([CLOC])</a></dt>

<dd>
<p>Destructively cleans %ENV - removes all variables %ENV except a selected few whitelisted variables.</p>

<p>The list of whitelisted %ENV variables are:</p>

<pre> PATH
 LC_ALL (*)
 TMPDIR</pre>

<p>(*) LC_ALL is a special case as clean_env will change its value to either &#34;C.UTF-8&#34; or &#34;C&#34; (if CLOC is given and a truth value).</p>

<dt><a name="perm2oct(PERM)"
>perm2oct(PERM)</a></dt>

<dd>
<p>Translates PERM to an octal permission. PERM should be a string describing the permissions as done by <i>tar t</i> or <i>ls -l</i>. That is, it should be a string like &#34;-rw-r--r--&#34;.</p>

<p>If the string does not appear to be a valid permission, it will cause a trappable error.</p>

<p>Examples:</p>

<pre> # Good
 perm2oct(&#39;-rw-r--r--&#39;) == 0644
 perm2oct(&#39;-rwxr-xr-x&#39;) == 0755

 # Bad
 perm2oct(&#39;broken&#39;)      # too short to be recognised
 perm2oct(&#39;-resurunet&#39;)  # contains unknown permissions</pre>

<dt><a name="run_cmd([OPTS,_]COMMAND[,_ARGS...])"
>run_cmd([OPTS, ]COMMAND[, ARGS...])</a></dt>

<dd>
<p>Executes the given <code>COMMAND</code> with the (optional) arguments <code>ARGS</code> and returns the status code as one would see it from a shell script. Shell features cannot be used.</p>

<p>OPTS, if given, is a hash reference with zero or more of the following key-value pairs:</p>

<dl>
<dt><a name="chdir"
>chdir</a></dt>

<dd>
<p>The child process with chdir to the given directory before executing the command.</p>

<dt><a name="in"
>in</a></dt>

<dd>
<p>The STDIN of the child process will be reopened and read from the filename denoted by the value of this key. By default, STDIN will reopened to read from /dev/null.</p>

<dt><a name="out"
>out</a></dt>

<dd>
<p>The STDOUT of the child process will be reopened and write to filename denoted by the value of this key. By default, STDOUT is discarded.</p>

<dt><a name="update-env-vars"
>update-env-vars</a></dt>

<dd>
<p>Each key/value pair defined in the hashref associated with <b>update-env-vars</b> will be updated in the child processes&#39;s environment. If a value is <code>undef</code>, then the corresponding environment variable will be removed (if set). Otherwise, the environment value will be set to that value.</p>
</dd>
</dl>

<dt><a name="copy_dir_(ARGS)"
>copy_dir (ARGS)</a></dt>

<dd>
<p>Convenient way of calling <i>cp -a ARGS</i>.</p>

<dt><a name="gunzip_file_(IN,_OUT)"
>gunzip_file (IN, OUT)</a></dt>

<dd>
<p>Decompresses contents of the file IN and stores the contents in the file OUT. IN is <i>not</i> removed by this call. On error, this function will cause a trappable error.</p>

<dt><a name="open_gz_(FILE)"
>open_gz (FILE)</a></dt>

<dd>
<p>Opens a handle that reads from the GZip compressed FILE.</p>

<p>On failure, this sub emits a trappable error.</p>

<p>Note: The handle may be a pipe from an external processes.</p>

<dt><a name="internal_error_(MSG[,_...])"
>internal_error (MSG[, ...])</a></dt>

<dd>
<p>Use to signal an internal error. The argument(s) will used to print a diagnostic message to the user.</p>

<p>If multiple arguments are given, they will be merged into a single string (by join (&#39; &#39;, @_)). If only one argument is given it will be stringified and used directly.</p>

<dt><a name="fail_(MSG[,_...])"
>fail (MSG[, ...])</a></dt>

<dd>
<p>Deprecated alias of &#34;internal_error&#34;.</p>

<dt><a name="locate_helper_tool(TOOLNAME)"
>locate_helper_tool(TOOLNAME)</a></dt>

<dd>
<p>Given the name of a helper tool, returns the path to it. The tool must be available in the &#34;helpers&#34; subdir of one of the &#34;lintian root&#34; directories used by Lintian.</p>

<p>The tool name should follow the same rules as check names. Particularly, third-party checks should namespace their tools in the same way they namespace their checks. E.g. &#34;python/some-helper&#34;.</p>

<p>If the tool cannot be found, this sub will cause a trappable error.</p>

<dt><a name="strip_([LINE])"
>strip ([LINE])</a></dt>

<dd>
<p>Strips whitespace from the beginning and the end of LINE and returns it. If LINE is omitted, <code>$_</code> will be used instead. Example</p>

<pre> @lines = map { strip } &#60;$fd&#62;;</pre>

<p>In void context, the input argument will be modified so it can be used as a replacement for chomp in some cases:</p>

<pre>  while ( my $line = &#60;$fd&#62; ) {
    strip ($line);
    # $line no longer has any leading or trailing whitespace
  }</pre>

<p>Otherwise, a copy of the string is returned:</p>

<pre>  while ( my $orig = &#60;$fd&#62; ) {
    my $stripped = strip ($orig);
    if ($stripped ne $orig) {
        # $orig had leading or/and trailing whitespace
    }
  }</pre>

<dt><a name="lstrip_([LINE])"
>lstrip ([LINE])</a></dt>

<dd>
<p>Like <a href="#strip_(%5BLINE%5D)" class="podlinkpod"
>strip</a> but only strip leading whitespace.</p>

<dt><a name="rstrip_([LINE])"
>rstrip ([LINE])</a></dt>

<dd>
<p>Like <a href="#strip_(%5BLINE%5D)" class="podlinkpod"
>strip</a> but only strip trailing whitespace.</p>

<dt><a name="check_path_(CMD)"
>check_path (CMD)</a></dt>

<dd>
<p>Returns 1 if CMD can be found in PATH (i.e. $ENV{PATH}) and is executable. Otherwise, the function return 0.</p>

<dt><a name="dequote_name(STR,_REMOVESLASH)"
>dequote_name(STR, REMOVESLASH)</a></dt>

<dd>
<p>Strip an extra layer quoting in index file names and optionally remove an initial &#34;./&#34; if any.</p>

<p>Remove initial ./ by default</p>

<dt><a name="signal_number2name(NUM)"
>signal_number2name(NUM)</a></dt>

<dd>
<p>Given a number, returns the name of the signal (without leading &#34;SIG&#34;). Example:</p>

<pre>    signal_number2name(2) eq &#39;INT&#39;</pre>

<dt><a name="normalize_pkg_path(PATH)"
>normalize_pkg_path(PATH)</a></dt>

<dd>
<p>Normalize PATH by removing superfluous path segments. PATH is assumed to be relative the package root. Note that the result will never start nor end with a slash, even if PATH does.</p>

<p>As the name suggests, this is a path &#34;normalization&#34; rather than a true path resolution (for that use Cwd::realpath). Particularly, it assumes none of the path segments are symlinks.</p>

<p>normalize_pkg_path will return <code>q{}</code> (i.e. the empty string) if PATH is normalized to the root dir and <code>undef</code> if the path cannot be normalized without escaping the package root.</p>

<p>Examples: normalize_pkg_path(&#39;usr/share/java/../../../usr/share/ant/file&#39;) eq &#39;usr/share/ant/file&#39; normalize_pkg_path(&#39;usr/..&#39;) eq q{};</p>

<pre> The following will return C&#60;undef&#62;:
  normalize_pkg_path(&#39;usr/bin/../../../../etc/passwd&#39;)</pre>

<dt><a name="normalize_pkg_path(CURDIR,_LINK_TARGET)"
>normalize_pkg_path(CURDIR, LINK_TARGET)</a></dt>

<dd>
<p>Normalize the path obtained by following a link with LINK_TARGET as its target from CURDIR as the current directory. CURDIR is assumed to be relative to the package root. Note that the result will never start nor end with a slash, even if CURDIR or DEST does.</p>

<p>normalize_pkg_path will return <code>q{}</code> (i.e. the empty string) if the target is the root dir and <code>undef</code> if the path cannot be normalized without escaping the package root.</p>

<p><b>CAVEAT</b>: This function is <i>not always sufficient</i> to test if it is safe to open a given symlink. Use <a href="../Lintian/Util.html#is_ancestor_of(PARENTDIR%2C_PATH)" class="podlinkpod"
>is_ancestor_of</a> for that. If you must use this function, remember to check that the target is not a symlink (or if it is, that it can be resolved safely).</p>

<p>Examples:</p>

<pre>  normalize_pkg_path(&#39;usr/share/java&#39;, &#39;../ant/file&#39;) eq &#39;usr/share/ant/file&#39;
  normalize_pkg_path(&#39;usr/share/java&#39;, &#39;../../../usr/share/ant/file&#39;)
  normalize_pkg_path(&#39;usr/share/java&#39;, &#39;/usr/share/ant/file&#39;)
    eq &#39;usr/share/ant/file&#39;
  normalize_pkg_path(&#39;/usr/share/java&#39;, &#39;/&#39;) eq q{};
  normalize_pkg_path(&#39;/&#39;, &#39;usr/..&#39;) eq q{};

 The following will return C&#60;undef&#62;:
  normalize_pkg_path(&#39;usr/bin&#39;, &#39;../../../../etc/passwd&#39;)
  normalize_pkg_path(&#39;usr/bin&#39;, &#39;/../etc/passwd&#39;)</pre>

<dt><a name="parse_boolean_(STR)"
>parse_boolean (STR)</a></dt>

<dd>
<p>Attempt to parse STR as a boolean and return its value. If STR is not a valid/recognised boolean, the sub will invoke croak.</p>

<p>The following values recognised (string checks are not case sensitive):</p>

<dl>
<dt><a name="The_integer_0_is_considered_false"
>The integer 0 is considered false</a></dt>

<dd>
<dt><a name="Any_non-zero_integer_is_considered_true"
>Any non-zero integer is considered true</a></dt>

<dd>
<dt><a name="&#34;true&#34;,_&#34;y&#34;_and_&#34;yes&#34;_are_considered_true"
>&#34;true&#34;, &#34;y&#34; and &#34;yes&#34; are considered true</a></dt>

<dd>
<dt><a name="&#34;false&#34;,_&#34;n&#34;_and_&#34;no&#34;_are_considered_false"
>&#34;false&#34;, &#34;n&#34; and &#34;no&#34; are considered false</a></dt>
</dl>

<dt><a name="is_ancestor_of(PARENTDIR,_PATH)"
>is_ancestor_of(PARENTDIR, PATH)</a></dt>

<dd>
<p>Returns true if and only if PATH is PARENTDIR or a path stored somewhere within PARENTDIR (or its subdirs).</p>

<p>This function will resolve the paths; any failure to resolve the path will cause a trappable error.</p>

<dt><a name="pipe_tee(INHANDLE,_OUTHANDLES[,_OPTS])"
>pipe_tee(INHANDLE, OUTHANDLES[, OPTS])</a></dt>

<dd>
<p>Read bytes from INHANDLE and copy them into all of the handles in the listref OUTHANDLES. The optional OPTS argument is a hashref of options, see below.</p>

<p>The subroutine will continue to read from INHANDLE until it is exhausted or an error occurs (either during read or write). In case of errors, a trappable error will be raised. The handles are left open when the subroutine returns, caller must close them afterwards.</p>

<p>Caller should ensure that handles are using &#34;blocking&#34; I/O. The subroutine will use <a href="../perlfunc.html#sysread" class="podlinkpod"
>sysread</a> and <a href="../perlfunc.html#syswrite" class="podlinkpod"
>syswrite</a> when reading and writing.</p>

<p>OPTS, if given, may contain the following key-value pairs:</p>

<dl>
<dt><a name="chunk_size"
>chunk_size</a></dt>

<dd>
<p>A suggested buffer size for read/write. If given, it will be to sysread as LENGTH argument when reading from INHANDLE.</p>
</dd>
</dl>

<dt><a name="untaint(VALUE)"
>untaint(VALUE)</a></dt>

<dd>
<p>Untaint VALUE</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SEE_ALSO"
>SEE ALSO</a></h1>

<p>lintian(1)</p>
<p class="backlinkbottom"><b><a name="___bottom" href="../index.html" title="All Documents">&lt;&lt;</a></b></p>

<!-- end doc -->

</body></html>
